def local_projection_irf(X: np.ndarray, p: int, H: int = 20, 
                        orthogonalize: bool = True) -> np.ndarray:
    """
    Implementación standalone de proyecciones locales para IRF.
    """
    T, n = X.shape
    irf = np.zeros((H + 1, n, n))
    
    # Matriz de covarianza para ortogonalización
    if orthogonalize:
        # Estimar VAR simple para obtener omega_hat
        X_lag, y = create_var_dataset(X, lag=p, add_intercept=True)
        pi = np.linalg.inv(X_lag.T @ X_lag) @ (X_lag.T @ y)
        residuals = y - X_lag @ pi
        omega_hat = (residuals.T @ residuals) / (T - p)
        impact_matrix = np.linalg.cholesky(omega_hat)
    else:
        impact_matrix = np.eye(n)
    
    # Para cada variable de shock y respuesta
    for shock_var in range(n):
        shock_direction = impact_matrix[:, shock_var]
        
        for response_var in range(n):
            for h in range(H + 1):
                # Preparar datos para la proyección local
                y_h = X[p + h:, response_var]  # Variable respuesta en t+h
                X_lp = np.ones((len(y_h), 1 + p * n))  # Intercepto + controles
                
                # Shock instrumentado en t
                innovations = np.zeros(len(y_h))
                for i in range(len(y_h)):
                    t = p + i
                    # Calcular innovación usando rezagos
                    pred = np.zeros(n)
                    for lag in range(1, p + 1):
                        pred += pi[1 + (lag-1)*n:1 + lag*n, :].T @ X[t - lag]
                    innovation = X[t] - pred
                    innovations[i] = innovation @ shock_direction
                
                X_lp[:, 0] = innovations
                
                # Agregar rezagos como controles
                for lag in range(1, p + 1):
                    for var in range(n):
                        col = 1 + (lag - 1) * n + var
                        X_lp[:, col] = X[p + h - lag: T - lag, var]
                
                # Estimar proyección local
                if len(y_h) > X_lp.shape[1]:
                    beta = np.linalg.inv(X_lp.T @ X_lp) @ (X_lp.T @ y_h)
                    irf[h, response_var, shock_var] = beta[0]
    
    return irf
