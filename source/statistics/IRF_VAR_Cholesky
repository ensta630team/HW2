import numpy as np

def IRF_VAR(self, H: int = 20, orthogonalize: bool = True) -> np.ndarray:
    """
    Calculo de la IRF.
    """
    if self.phi is None:
        raise ValueError("El modelo debe ser ajustado primero con el método .fit()")
    
    if orthogonalize and self.omega_hat is None:
        raise ValueError("Para IRF orthogonalizada, el modelo debe tener omega_hat estimado")
    
    n = self.inp_dim
    p = self.p
    
    # Construir matriz F
    F = self._build_F_matrix()
    J = np.eye(n * p, n * p)[:n, :]
    
    # Matriz de impacto inicial
    if orthogonalize:
        # Descomposición de Cholesky con numpy (más lento pero funciona)
        impact_matrix = np.linalg.cholesky(self.omega_hat)
    else:
        impact_matrix = np.eye(n)
    
    # Precalcular potencias de F eficientemente
    irf = np.zeros((H + 1, n, n))
    irf[0] = impact_matrix
    
    # Estado actual para el cálculo iterativo
    if H > 0:
        # Precomputar J @ F^t @ J.T para t=1 hasta H
        current_power = np.eye(F.shape[0])  # F^0
        JTP = J.T @ impact_matrix  # Precomputar una vez
        
        for t in range(1, H + 1):
            current_power = current_power @ F
            irf[t] = J @ current_power @ JTP
    
    return irf

def Cholesky(matrix):
    """
    Implementación de Cholesky.
    """
    n = matrix.shape[0]
    L = np.zeros_like(matrix)
    
    for i in range(n):
        for j in range(i+1):
            if i == j:
                sum_val = np.sum(L[i, :j]**2)
                L[i, j] = np.sqrt(matrix[i, i] - sum_val)
            else:
                sum_val = np.sum(L[i, :j] * L[j, :j])
                L[i, j] = (matrix[i, j] - sum_val) / L[j, j]
    
    return L